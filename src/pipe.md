# パイプ演算子

プログラムをこれまでにある程度書いたことがあれば，関数が入れ子になって可読性が下がったという経験があることでしょう．Elixirにはそれを解決する良い演算子があります．以下の関数を例に取りましょう．

```
Enum.reduce(Enum.filter(Enum.map(1..10_000, &(&1 + 2)), &(rem(&1, 2) == 0)), 0, &+/2)
```

上記は3重の入れ子になっていて非常に読みづらくなっています．頑張って処理を読み解くと，1から1万までの数字に2を足し，その結果の偶数のみを加算していると言うことがわかります．こんなコードをレビューしてくれと言われた日には発狂する自信があります．

恐らく他言語なら各処理の結果を1つずつ変数に格納すると言った方法をとるでしょう．しかし，1回しか使わない，しかも次の行で使用する値をいちいち変数に格納するのはあまりスマートではありません．Elixirではこのようなジレンマをパイプ演算子を用いて解決することが出来ます．

```
1..10_000
|> Enum.map(&(&1 + 2))
|> Enum.filter(&(rem(&1, 2) == 0))
|> Enum.reduce(0, &+/2)
```

とても読みやすく書き直すことが出来ました．この書き方は入れ子を解決するだけで無く，データを処理する順番に関数を並べることができるというメリットも得られます．

パイプライン演算子は左辺の評価結果を右辺の関数の第1引数に与えるという挙動をします．

#### **関数の結果のハンドリングに用いる**

Elixirでは成功するかわからない関数の結果が`{:ok, ...}`，`{:error, ...}`として返される場合があります．成功した場合だけその結果を用いて次の処理をしたいという場合，case文を使えば簡単に書くことができます．

```
case func(arg) do
  {:ok, result} -> next_func(result)
  error         -> error              # {:error, ...}をerrorとしてマッチしています
end
```

さらに，パイプ演算子を用いてこのように書くこともできます．

```
func(arg)
|> case do
  {:ok, result} -> next_func(result)
  error         -> error
end
```
